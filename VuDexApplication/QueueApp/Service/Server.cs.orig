///////////////////////////////////////////////////////////
//  Server.cs
//  Implementation of the Class Server
//  Generated by Enterprise Architect
//  Created on:      05-May-2019 22:35:12
//  Original author: vule9
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading.Tasks;
using System.Xml.Serialization;
using System.Xml;
using System.Collections.Concurrent;
using QueueApp.Model;
using QueueApp.Common;
using QueueApp.Repository;
using QueueApp.View;
using System.Threading;

public class Server : QueueAndXmlOperations
{
    #region Fields
    public Dictionary<String, ClientQueue> ClientQueues;
    public Queue DbQueue;
    public Queue ServerQueue;
    AutoResetEvent resetEvent = new AutoResetEvent(false);
    #endregion

    public Server()
    {
        ServerQueue = new ServerQueue();
        ClientQueues = new Dictionary<String, ClientQueue>();
        DbQueue = new DbQueue();
        Task.Factory.StartNew(() => ListeningOnServerQueue());
        Task.Factory.StartNew(() => ListeningDbQueue());
    }
    ~Server()
    {

    }

    #region Commands
    private Packet Create(Packet packet)
    {
        if (!ClientQueues.ContainsKey(packet.Message))
        {
            ClientQueue queue = new ClientQueue()
            {
                Title = packet.Message
            };
            queue.SubscribedClients.Add(packet.User);
            ClientQueues.Add(queue.Title, queue);

            Task.Factory.StartNew(() => ListeningOnClientQueue(queue.QueueA));

            // TREBA VRATITI KLIJENTU DA JE RED USPESNO NAPRAVLJEN
            packet.User.SubscribedTo = packet.Message;   // klijent je pretplacen na neki red
            packet.Message = $"Queue with '{packet.Message}' title is successfully created.";
        }
        else
        {
            // POSLATI DA JE TITLE ZAUZET
            packet.Message = $"Queue with '{packet.Message}' title is already taken.";
        }

        return packet;
    }
    private bool Subscribe(Packet p)
    {
        if (ClientQueues.ContainsKey(p.Message))  //ako postoji red sa ovim nazivom u recniku klijentskih redova
        {
            ClientQueues[p.Message].SubscribedClients.Add(p.User);
            return true;
        }

        return false;
    }
    private void Update(String xml)
    {
        Push(DbQueue.QueueA, xml);
    }
    #endregion

    #region Listeners
    private void ListeningDbQueue()
    {
        while (true)
        {
            if(this.DbQueue.QueueB.Count > 0)
            {
                string text = Pop(this.DbQueue.QueueB);
                Packet packet = Deserialize(text);

                if (packet.Message == "1")
                {
                    packet.Message = "Your data was successfully updated.";
                    ClientQueues[packet.User.SubscribedTo].SubscribedClients.Find(x => x.UserId.Equals(packet.User.UserId));
                }
                else if(packet.Message == "0")
                {
                    packet.Message = "Your data was unsuccessfully updated.";
                }
                text = Serialize(packet);
                //vracamo klijentu poruku o uspesnosti metode
                Push(ClientQueues[packet.User.SubscribedTo].QueueB, text);
            }
            Thread.Sleep(1000);
        }
    }
    private void ListeningOnServerQueue()
    {
        while (true)
        {
            if(ServerQueue.QueueA.Count > 0)
            {
                string text = Pop(ServerQueue.QueueA);
                Packet packet = Deserialize(text);

                if (packet.TypeOfRequest == RequestType.CREATE)
                {
                    packet = Create(packet);
                    string response = Serialize(packet);
                    Push(DbQueue.QueueA, response);
                    Push(ServerQueue.QueueB, response);
                }
                else if(packet.TypeOfRequest == RequestType.SUBSCRIBE)
                {
                    if (Subscribe(packet))  //obezbedjen subscribe
                    {
                        packet.User.SubscribedTo = packet.Message;
                        packet.Message = "Successfully subscribed!";
                        Push(DbQueue.QueueA, Serialize(packet));
                        Push(ServerQueue.QueueB,Serialize(packet));
                    }
                    else
                    {
                        packet.Message = "Unsuccessfully subscribed! No requested queue!";
                        Push(ServerQueue.QueueB, Serialize(packet));
                    }
                }
            }
            Thread.Sleep(1000);
        }
    }
    private void ListeningOnClientQueue(ConcurrentQueue<String> queue)
    {
        while (true)
        {
            if (queue.Count > 0)
            {
                string text = Pop(queue);
                Packet packet = Deserialize(text);

                if (packet.TypeOfRequest == RequestType.UPDATE)
                {
                    Update(text);
                }
            }
            Thread.Sleep(1000);
        }
    }
    #endregion
}//end Server